name: Build and Push Docker Images

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: docker.io
  NAMESPACE: zyg5467

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64
        
    - name: Debug Docker Hub credentials
      run: |
        echo "Checking DockerHub credentials..."
        if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
          echo "ERROR: DOCKERHUB_USERNAME secret is not set"
          exit 1
        fi
        if [ -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
          echo "ERROR: DOCKERHUB_TOKEN secret is not set"
          exit 1
        fi
        echo "DockerHub username: ${{ secrets.DOCKERHUB_USERNAME }}"
        echo "DockerHub token is set: $(if [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then echo 'YES'; else echo 'NO'; fi)"
        
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        
    - name: Install Python and hatch
      run: |
        python -m pip install --upgrade pip
        python -m pip install hatch
        
    - name: Build and distribute commons library  
      run: |
        echo "ðŸ”¨ Building commons library using project build scripts..."
        
        # Step 1: Build commons using run_build_common.sh
        if [ -f "./scripts/run_build_common.sh" ]; then
          echo "ðŸ“‹ Building commons package..."
          chmod +x ./scripts/run_build_common.sh
          ./scripts/run_build_common.sh
        else
          echo "âŒ run_build_common.sh not found"
          exit 1
        fi
        
        # Step 2: Copy commons to all services using run_copy_common.sh
        if [ -f "./scripts/run_copy_common.sh" ]; then
          echo "ðŸ“‹ Copying commons to all services..."
          chmod +x ./scripts/run_copy_common.sh
          ./scripts/run_copy_common.sh
        else
          echo "âŒ run_copy_common.sh not found"
          exit 1
        fi
        
        # Step 3: Update Pipfiles with new version
        echo "ðŸ“‹ Updating service Pipfiles with new commons version..."
        COMMONS_DIST_DIR="./services/commons/dist"
        LATEST_WHEEL=$(ls -t "$COMMONS_DIST_DIR"/kugel_common-*-py3-none-any.whl 2>/dev/null | head -n 1)
        
        if [ -n "$LATEST_WHEEL" ]; then
          WHEEL_FILENAME=$(basename "$LATEST_WHEEL")
          VERSION=$(echo "$WHEEL_FILENAME" | cut -d'-' -f2)
          echo "  Latest version: $VERSION"
          
          # Update each service's Pipfile
          SERVICES=(account terminal master-data cart report journal stock)
          for service in "${SERVICES[@]}"; do
            PIPFILE="./services/$service/Pipfile"
            if [ -f "$PIPFILE" ]; then
              # Update Pipfile with new version
              sed -i "s|kugel_common = {file = \"commons/dist/kugel_common-[0-9.]*-py3-none-any\\.whl\"}|kugel_common = {file = \"commons/dist/kugel_common-${VERSION}-py3-none-any.whl\"}|" "$PIPFILE"
              echo "  âœ… Updated $service Pipfile"
            fi
          done
        else
          echo "âŒ No commons wheel file found"
          exit 1
        fi
        
        echo "ðŸ“‹ Verifying commons distribution:"
        for service in account terminal master-data cart report journal stock; do
          if [ -d "./services/$service/commons/dist" ]; then
            echo "  âœ… $service: $(ls -la ./services/$service/commons/dist/ | wc -l) files"
          else
            echo "  âŒ $service: commons/dist directory not found"
          fi
        done
        
    - name: Build and push all Docker images
      id: build-images
      run: |
        SERVICES="account terminal master-data cart report journal stock"
        
        # Initialize digest environment file
        echo "# Docker image digests" > /tmp/digests.env
        
        # Build and push each service
        for service in $SERVICES; do
          echo "ðŸš€ Building and pushing $service..."
          
          # Check if service directory exists
          if [ ! -d "./services/$service" ]; then
            echo "âŒ Service directory ./services/$service not found"
            exit 1
          fi
          
          echo "ðŸ“‚ Contents of ./services/$service:"
          ls -la ./services/$service
          
          # Check if commons is available
          if [ -d "./services/$service/commons/dist" ]; then
            echo "âœ… Commons found for $service:"
            ls -la ./services/$service/commons/dist/
          else
            echo "âš ï¸  No commons dist found for $service"
          fi
          
          # Check if Dockerfile exists
          if [ ! -f "./services/$service/Dockerfile" ]; then
            echo "âŒ Dockerfile not found for $service"
            exit 1
          fi
          
          # Build and push image with better error handling
          echo "ðŸ”¨ Building Docker image for $service..."
          
          # Build with explicit output format to avoid OCI issues
          if docker buildx build \
            --platform linux/amd64 \
            --output type=image,name=${{ env.REGISTRY }}/${{ env.NAMESPACE }}/pos-$service:latest,push=true \
            ./services/$service; then
            echo "âœ… Successfully built and pushed $service"
          else
            echo "âŒ Failed to build $service"
            exit 1
          fi
            
          # Wait longer for the image to be available on DockerHub
          echo "â³ Waiting for image to be available on DockerHub..."
          sleep 30
          
          # Get the digest using multiple methods
          echo "ðŸ“‹ Getting digest for $service..."
          DIGEST=""
          IMAGE_FULL_NAME="${{ env.REGISTRY }}/${{ env.NAMESPACE }}/pos-$service:latest"
          
          for attempt in 1 2 3; do
            echo "  Attempt $attempt: Getting digest for $service..."
            
            # Method 1: Use docker manifest inspect
            DIGEST=$(docker manifest inspect "$IMAGE_FULL_NAME" 2>/dev/null | jq -r '.digest // empty' 2>/dev/null || echo "")
            
            # Method 2: If method 1 fails, try docker buildx imagetools
            if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ] || [ "$DIGEST" = "empty" ]; then
              echo "    Trying method 2: buildx imagetools..."
              DIGEST=$(docker buildx imagetools inspect "$IMAGE_FULL_NAME" --format '{{.Manifest.Digest}}' 2>/dev/null || echo "")
            fi
            
            # Method 3: If both fail, try docker inspect on local image
            if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ] || [ "$DIGEST" = "empty" ]; then
              echo "    Trying method 3: Local image inspection..."
              DIGEST=$(docker inspect "$IMAGE_FULL_NAME" --format='{{index .RepoDigests 0}}' 2>/dev/null | cut -d'@' -f2 || echo "")
            fi
            
            if [ -n "$DIGEST" ] && [ "$DIGEST" != "null" ] && [ "$DIGEST" != "empty" ] && [ "$DIGEST" != "" ]; then
              echo "  âœ… Got digest: $DIGEST"
              break
            fi
            
            echo "  â³ Attempt $attempt failed, waiting longer before retry..."
            sleep 15
          done
          
          if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ]; then
            echo "âš ï¸  Failed to get digest for $service after 3 attempts"
            echo "ðŸ”„ Using timestamp-based fallback method..."
            
            # Fallback: Use current timestamp as a pseudo-digest
            TIMESTAMP=$(date +%s)
            DIGEST="sha256:fallback-${TIMESTAMP}-${service}"
            echo "ðŸ“‹ Using fallback digest: $DIGEST"
            
            # Save a note that this was a fallback
            echo "# Fallback digest used for $service" >> /tmp/digest_warnings.txt
          fi
          
          # Save digest to both GitHub output and temporary file
          DIGEST_VAR="${service//-/_}_digest"
          ENV_VAR_NAME=$(echo "$service" | tr '[:lower:]-' '[:upper:]_')_DIGEST
          
          echo "$DIGEST_VAR=$DIGEST" >> "$GITHUB_OUTPUT"
          echo "${ENV_VAR_NAME}=$DIGEST" >> /tmp/digests.env
          
          echo "âœ… Built $service with digest: $DIGEST"
        done
        
   