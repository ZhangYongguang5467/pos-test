name: Build and Push Docker Images

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: docker.io
  NAMESPACE: zyg5467

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64
        
    - name: Debug Docker Hub credentials
      run: |
        echo "Checking DockerHub credentials..."
        if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
          echo "ERROR: DOCKERHUB_USERNAME secret is not set"
          exit 1
        fi
        if [ -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
          echo "ERROR: DOCKERHUB_TOKEN secret is not set"
          exit 1
        fi
        echo "DockerHub username: ${{ secrets.DOCKERHUB_USERNAME }}"
        echo "DockerHub token is set: $(if [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then echo 'YES'; else echo 'NO'; fi)"
        
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        
    - name: Install Python and hatch
      run: |
        python -m pip install --upgrade pip
        python -m pip install hatch
        
    - name: Build and distribute commons library  
      run: |
        echo "üî® Building commons library using project build scripts..."
        
        # Step 1: Build commons using run_build_common.sh
        if [ -f "./scripts/run_build_common.sh" ]; then
          echo "üìã Building commons package..."
          chmod +x ./scripts/run_build_common.sh
          ./scripts/run_build_common.sh
        else
          echo "‚ùå run_build_common.sh not found"
          exit 1
        fi
        
        # Step 2: Copy commons to all services using run_copy_common.sh
        if [ -f "./scripts/run_copy_common.sh" ]; then
          echo "üìã Copying commons to all services..."
          chmod +x ./scripts/run_copy_common.sh
          ./scripts/run_copy_common.sh
        else
          echo "‚ùå run_copy_common.sh not found"
          exit 1
        fi
        
        # Step 3: Update Pipfiles with new version
        echo "üìã Updating service Pipfiles with new commons version..."
        COMMONS_DIST_DIR="./services/commons/dist"
        LATEST_WHEEL=$(ls -t "$COMMONS_DIST_DIR"/kugel_common-*-py3-none-any.whl 2>/dev/null | head -n 1)
        
        if [ -n "$LATEST_WHEEL" ]; then
          WHEEL_FILENAME=$(basename "$LATEST_WHEEL")
          VERSION=$(echo "$WHEEL_FILENAME" | cut -d'-' -f2)
          echo "  Latest version: $VERSION"
          
          # Update each service's Pipfile
          SERVICES=(account terminal master-data cart report journal stock)
          for service in "${SERVICES[@]}"; do
            PIPFILE="./services/$service/Pipfile"
            if [ -f "$PIPFILE" ]; then
              # Update Pipfile with new version
              sed -i "s|kugel_common = {file = \"commons/dist/kugel_common-[0-9.]*-py3-none-any\\.whl\"}|kugel_common = {file = \"commons/dist/kugel_common-${VERSION}-py3-none-any.whl\"}|" "$PIPFILE"
              echo "  ‚úÖ Updated $service Pipfile"
            fi
          done
        else
          echo "‚ùå No commons wheel file found"
          exit 1
        fi
        
        echo "üìã Verifying commons distribution:"
        for service in account terminal master-data cart report journal stock; do
          if [ -d "./services/$service/commons/dist" ]; then
            echo "  ‚úÖ $service: $(ls -la ./services/$service/commons/dist/ | wc -l) files"
          else
            echo "  ‚ùå $service: commons/dist directory not found"
          fi
        done
        
    - name: Build and push all Docker images
      id: build-images
      run: |
        SERVICES="account terminal master-data cart report journal stock"
        
        # Initialize digest environment file
        echo "# Docker image digests" > /tmp/digests.env
        
        # Build and push each service
        for service in $SERVICES; do
          echo "üöÄ Building and pushing $service..."
          
          # Check if service directory exists
          if [ ! -d "./services/$service" ]; then
            echo "‚ùå Service directory ./services/$service not found"
            exit 1
          fi
          
          echo "üìÇ Contents of ./services/$service:"
          ls -la ./services/$service
          
          # Check if commons is available
          if [ -d "./services/$service/commons/dist" ]; then
            echo "‚úÖ Commons found for $service:"
            ls -la ./services/$service/commons/dist/
          else
            echo "‚ö†Ô∏è  No commons dist found for $service"
          fi
          
          # Check if Dockerfile exists
          if [ ! -f "./services/$service/Dockerfile" ]; then
            echo "‚ùå Dockerfile not found for $service"
            exit 1
          fi
          
          # Build and push image with better error handling
          echo "üî® Building Docker image for $service..."
          
          # Build with explicit output format to avoid OCI issues
          if docker buildx build \
            --platform linux/amd64 \
            --output type=image,name=${{ env.REGISTRY }}/${{ env.NAMESPACE }}/pos-$service:latest,push=true \
            ./services/$service; then
            echo "‚úÖ Successfully built and pushed $service"
          else
            echo "‚ùå Failed to build $service"
            exit 1
          fi
            
          # Wait longer for the image to be available on DockerHub
          echo "‚è≥ Á≠âÂæÖÈïúÂÉèÂú®DockerHub‰∏äÂèØÁî®..."
          sleep 30
          
          # Get the digest using multiple methods
          echo "üìã Getting digest for $service..."
          DIGEST=""
          IMAGE_FULL_NAME="${{ env.REGISTRY }}/${{ env.NAMESPACE }}/pos-$service:latest"
          
          for attempt in 1 2 3; do
            echo "  Â∞ùËØï $attempt: Ëé∑Âèñ $service ÁöÑÊëòË¶Å..."
            
            # Method 1: Use docker manifest inspect
            DIGEST=$(docker manifest inspect "$IMAGE_FULL_NAME" 2>/dev/null | jq -r '.digest // empty' 2>/dev/null || echo "")
            
            # Method 2: If method 1 fails, try docker buildx imagetools
            if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ] || [ "$DIGEST" = "empty" ]; then
              echo "    Â∞ùËØïÊñπÊ≥ï2: buildx imagetools..."
              DIGEST=$(docker buildx imagetools inspect "$IMAGE_FULL_NAME" --format '{{.Manifest.Digest}}' 2>/dev/null || echo "")
            fi
            
            # Method 3: If both fail, try docker inspect on local image
            if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ] || [ "$DIGEST" = "empty" ]; then
              echo "    Â∞ùËØïÊñπÊ≥ï3: Êú¨Âú∞ÈïúÂÉèÊ£ÄÊü•..."
              DIGEST=$(docker inspect "$IMAGE_FULL_NAME" --format='{{index .RepoDigests 0}}' 2>/dev/null | cut -d'@' -f2 || echo "")
            fi
            
            if [ -n "$DIGEST" ] && [ "$DIGEST" != "null" ] && [ "$DIGEST" != "empty" ] && [ "$DIGEST" != "" ]; then
              echo "  ‚úÖ Ëé∑ÂèñÂà∞ÊëòË¶Å: $DIGEST"
              break
            fi
            
            echo "  ‚è≥ Â∞ùËØï $attempt Â§±Ë¥•ÔºåÁ≠âÂæÖÊõ¥ÈïøÊó∂Èó¥ÂêéÈáçËØï..."
            sleep 15
          done
          
          if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ]; then
            echo "‚ö†Ô∏è  Failed to get digest for $service after 3 attempts"
            echo "üîÑ Using timestamp-based fallback method..."
            
            # Fallback: Use current timestamp as a pseudo-digest
            TIMESTAMP=$(date +%s)
            DIGEST="sha256:fallback-${TIMESTAMP}-${service}"
            echo "üìã Using fallback digest: $DIGEST"
            
            # Save a note that this was a fallback
            echo "# Fallback digest used for $service" >> /tmp/digest_warnings.txt
          fi
          
          # Save digest to both GitHub output and temporary file
          DIGEST_VAR="${service//-/_}_digest"
          ENV_VAR_NAME=$(echo "$service" | tr '[:lower:]-' '[:upper:]_')_DIGEST
          
          echo "$DIGEST_VAR=$DIGEST" >> "$GITHUB_OUTPUT"
          echo "${ENV_VAR_NAME}=$DIGEST" >> /tmp/digests.env
          
          echo "‚úÖ Built $service with digest: $DIGEST"
        done
        
    - name: Update docker-compose.yaml with SHA256 digests
      run: |
        echo "üìã Reading digest values from previous step..."
        
        # Read digests from a temporary file instead of GitHub outputs
        if [ -f "/tmp/digests.env" ]; then
          source /tmp/digests.env
          
          echo "Found digests:"
          echo "  ACCOUNT_DIGEST=$ACCOUNT_DIGEST"
          echo "  TERMINAL_DIGEST=$TERMINAL_DIGEST"  
          echo "  MASTER_DATA_DIGEST=$MASTER_DATA_DIGEST"
          echo "  CART_DIGEST=$CART_DIGEST"
          echo "  REPORT_DIGEST=$REPORT_DIGEST"
          echo "  JOURNAL_DIGEST=$JOURNAL_DIGEST"
          echo "  STOCK_DIGEST=$STOCK_DIGEST"
          
          # Run the update script
          chmod +x ./scripts/update_compose_digests.sh
          ./scripts/update_compose_digests.sh --use-env
        else
          echo "‚ùå No digest file found at /tmp/digests.env"
          exit 1
        fi
        
    - name: Commit and push updated docker-compose.yaml
      run: |
        cd services
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add docker-compose.yaml
        
        # Check if there are any changes to commit
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          # Source the digest values for commit message
          source /tmp/digests.env
          
          git commit -m "chore: update docker-compose.yaml with latest image SHA256 digests" \
                     -m "" \
                     -m "ü§ñ Generated by GitHub Actions" \
                     -m "" \
                     -m "- account: $ACCOUNT_DIGEST" \
                     -m "- terminal: $TERMINAL_DIGEST" \
                     -m "- master-data: $MASTER_DATA_DIGEST" \
                     -m "- cart: $CART_DIGEST" \
                     -m "- report: $REPORT_DIGEST" \
                     -m "- journal: $JOURNAL_DIGEST" \
                     -m "- stock: $STOCK_DIGEST"
          git push
        fi