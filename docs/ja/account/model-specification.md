# アカウントサービスモデル仕様

## 概要

アカウントサービスは、ユーザー認証とアカウント管理のためのデータモデル、APIスキーマ、およびそれらの間の変換を管理するトランスフォーマーで構成されています。すべてのモデルには、データの整合性とセキュリティを確保するための厳格な型定義と検証ルールがあります。

## データベースドキュメントモデル

### 1. UserAccountDocument（ユーザーアカウントドキュメント）

セキュアな資格情報管理を持つユーザーアカウント情報を保存するためのメインドキュメント。

**フィールド定義:**

| フィールド名 | 型 | 必須 | 説明 |
|------------|------|----------|-------------|
| username | string | ✓ | テナント内での一意のユーザー名 |
| hashed_password | string | ✓ | ソルト付きBCryptハッシュ化パスワード |
| tenant_id | string | ✓ | マルチテナント分離のためのテナント識別子 |
| is_superuser | bool | ✓ | 管理者権限フラグ（デフォルト: False） |
| is_active | bool | ✓ | アカウントステータスフラグ（デフォルト: True） |
| created_at | datetime | ✓ | アカウント作成タイムスタンプ |
| updated_at | datetime | - | 最終更新タイムスタンプ |
| last_login | datetime | - | 最終ログイン成功タイムスタンプ |
| shard_key | string | ✓ | シャーディングキー（AbstractDocumentから継承） |
| etag | string | ✓ | 楽観的ロックのためのETag（AbstractDocumentから継承） |

**インデックス:**
- 複合ユニークインデックス: (tenant_id, username) - テナントごとの一意のユーザー名を保証
- インデックス: tenant_id
- インデックス: is_active
- インデックス: is_superuser

**コレクション名:** "user_accounts"

**セキュリティ機能:**
- プレーンテキストパスワードは保存されません
- 自動ソルト生成によるBCryptハッシュ化
- データベースレベルでのテナント分離
- ETagによる楽観的ロック

## APIリクエストスキーマ

すべてのスキーマは`BaseSchemaModel`から継承し、以下の機能を提供します：
- JSONフィールドの自動camelCase変換（snake_case → camelCase）
- 型安全性を持つPydantic検証
- セキュアなパスワード処理

### 1. BaseUserAccount（登録リクエストスキーマ）

ユーザーアカウント作成リクエストのベーススキーマ。

**フィールド定義:**

| フィールド名 | 型 | 必須 | 検証 | 説明 |
|------------|------|----------|------------|-------------|
| username | string | ✓ | 3-50文字、英数字+アンダースコア | 認証用ユーザー名 |
| password | string | ✓ | 8文字以上（設定可能） | プレーンテキストパスワード（保存されません） |
| tenantId | string | - | 5文字: 1文字+4桁 | テナント識別子（未提供の場合は自動生成） |

**検証ルール:**
- `username`: テナント内で一意、3-50文字、英数字とアンダースコアのみ
- `password`: 最小8文字、BCryptハッシュとして保存
- `tenantId`: 形式検証（A1234）、スーパーユーザー登録時は自動生成

### 2. OAuth2PasswordRequestForm（ログインリクエスト）

認証のための標準OAuth2パスワードフローリクエスト。

**フィールド定義:**

| フィールド名 | 型 | 必須 | 説明 |
|------------|------|----------|-------------|
| username | string | ✓ | ユーザーのユーザー名 |
| password | string | ✓ | ユーザーのパスワード |
| client_id | string | ✓ | テナントID（OAuth2クライアント識別子として使用） |
| grant_type | string | - | OAuth2グラントタイプ（デフォルト: "password"） |
| scope | string | - | OAuth2スコープ（デフォルト: ""） |

**使用上の注意:**
- OAuth2パスワードフロー標準に従います
- `client_id`フィールドにはマルチテナント認証用のテナントIDが含まれます
- フォームエンコードされたリクエストボディ（application/x-www-form-urlencoded）

## APIレスポンススキーマ

### 1. BaseUserAccountInDB（ユーザーアカウントレスポンス）

セキュアなフィールド処理を持つユーザーアカウント情報のレスポンススキーマ。

**フィールド定義:**

| フィールド名 | 型 | 説明 |
|------------|------|-------------|
| username | string | ユーザー名 |
| password | string | セキュリティのため常に"*****"としてマスク |
| tenantId | string | テナント識別子 |
| isSuperuser | bool | 管理者権限フラグ |
| isActive | bool | アカウントステータス |
| createdAt | datetime | アカウント作成タイムスタンプ |
| updatedAt | datetime (オプション) | 最終更新タイムスタンプ |
| lastLogin | datetime (オプション) | 最終ログイン成功タイムスタンプ |

**セキュリティ機能:**
- `password`フィールドは露出を防ぐため常に"*****"を返します
- `hashedPassword`フィールドはレスポンスに含まれません
- 自動タイムスタンプ管理
- フロントエンド互換性のためのcamelCase変換

### 2. BaseLoginResponse（認証レスポンス）

認証成功時のレスポンススキーマ。

**フィールド定義:**

| フィールド名 | 型 | 説明 |
|------------|------|-------------|
| access_token | string | API認証用のJWTトークン |
| token_type | string | トークンタイプ（"bearer"） |

**注意:** このスキーマは`BaseModel`（`BaseSchemaModel`ではない）から継承されるため、フィールドはsnake_case形式のままです。

**トークン構造:**
JWTトークンには以下のクレームが含まれます：
- `sub`: ユーザー名
- `tenant_id`: テナント識別子
- `is_superuser`: 管理者権限フラグ
- `is_active`: アカウントステータス
- `exp`: トークン有効期限タイムスタンプ
- `iat`: トークン発行時刻タイムスタンプ

### 3. HealthCheckResponse（ヘルスチェックレスポンス）

サービスヘルスモニタリングのレスポンススキーマ。

**フィールド定義:**

| フィールド名 | 型 | 説明 |
|------------|------|-------------|
| status | string | サービスステータス（"healthy"、"unhealthy"） |
| database | string | データベース接続ステータス（"connected"、"disconnected"） |
| timestamp | datetime | ヘルスチェックタイムスタンプ |

## JWTトークンモデル

### JWTクレーム構造

JWTトークンペイロードには以下の標準化されたクレームが含まれます：

```json
{
  "sub": "username",           // サブジェクト（ユーザー名）
  "tenant_id": "A1234",        // テナント識別子
  "is_superuser": false,       // 管理者権限
  "is_active": true,           // アカウントステータス
  "exp": 1640995200,           // 有効期限タイムスタンプ
  "iat": 1640991600            // 発行時刻タイムスタンプ
}
```

### トークン設定

**環境設定:**
- `SECRET_KEY`: JWT署名シークレット
- `ALGORITHM`: 署名アルゴリズム（デフォルト: HS256）
- `TOKEN_EXPIRE_MINUTES`: トークン有効期限（デフォルト: 30分）

## データフローと関係

### 1. ユーザー登録フロー
```
[APIリクエスト] → [スキーマ検証] → [パスワードハッシュ化]
    ↓
[テナント検証/生成] → [UserAccountDocument作成]
    ↓
[データベース保存] → [レスポンス変換] → [APIレスポンス]
```

### 2. 認証フロー
```
[ログインリクエスト] → [資格情報検証] → [ユーザー検索]
    ↓
[パスワード検証] → [JWTトークン生成] → [ログインタイムスタンプ更新]
    ↓
[トークンレスポンス] → [APIレスポンス]
```

### 3. トークン検証フロー
```
[受信リクエスト] → [JWTトークン抽出] → [トークン検証]
    ↓
[クレーム抽出] → [ユーザーステータス検証] → [リクエスト認可]
```

## 検証ルール

### 1. ユーザー名検証
- **長さ**: 3-50文字
- **文字**: 英数字とアンダースコアのみ（正規表現: `^[a-zA-Z0-9_]+$`）
- **一意性**: テナント内で一意である必要があります
- **大文字小文字**: 大文字小文字を区別するユーザー名

### 2. パスワード検証
- **最小長**: 8文字（環境で設定可能）
- **ハッシュ化**: 自動ソルト生成によるBCrypt
- **保存**: データベースにはハッシュ化されたパスワードのみ保存
- **検証**: プレーンテキストパスワードはハッシュに対して検証

### 3. テナントID検証
- **形式**: 1文字の後に4桁（例: "A1234"）
- **生成**: スーパーユーザー登録時に提供されない場合は自動生成
- **一意性**: すべてのテナント間で一意である必要があります
- **検証**: 正規表現パターン `^[A-Z][0-9]{4}$`

### 4. JWTトークン検証
- **署名**: シークレットキーとアルゴリズムを使用して検証
- **有効期限**: トークンは期限切れでない必要があります
- **クレーム**: 必須クレームが存在し有効である必要があります
- **ユーザーステータス**: ユーザーは存在しアクティブである必要があります

## セキュリティ機能

### 1. パスワードセキュリティ
- **BCryptハッシュ化**: ソルト付きの業界標準パスワードハッシュ化
- **プレーンテキスト非保存**: パスワードはプレーンテキストで保存されません
- **セキュアな比較**: 定数時間パスワード検証
- **ハッシュ強度**: 設定可能なワークファクター（デフォルト: 12ラウンド）

### 2. マルチテナント分離
- **データベース分離**: 各テナントに専用データベース
- **アクセス制御**: アプリケーションレベルでのクロステナントアクセス防止
- **一意制約**: テナントスコープ内でのユーザー名の一意性
- **データ分離**: テナントデータの完全な分離

### 3. JWTトークンセキュリティ
- **署名付きトークン**: 整合性のためのHMAC-SHA256署名
- **有効期限**: 設定可能なトークンライフタイム
- **最小クレーム**: ペイロードには必要な情報のみ
- **ステートレス**: サーバー側のセッション保存不要

### 4. 認証セキュリティ
- **アクティブユーザーチェック**: 非アクティブユーザーは認証不可  
- **テナント検証**: 認証のためにテナントが存在する必要があります
- **監査ログ**: ログイン試行と認証イベントがログ記録されます
- **セキュアなエンドポイント**: 重要なエンドポイントには適切な認証が必要

## フィールド命名規則

### 1. データベースモデル
- **規約**: snake_case（例: `is_superuser`）
- **理由**: PythonとMongoDBの標準命名

### 2. APIスキーマ
- **規約**: camelCase（例: `isSuperuser`）
- **理由**: JavaScript/TypeScriptフロントエンド互換性
- **変換**: `BaseSchemaModel`による自動変換

### 3. 変換例
```
データベース: is_superuser → API: isSuperuser
データベース: created_at → API: createdAt
データベース: last_login → API: lastLogin
データベース: tenant_id → API: tenantId
データベース: hashed_password → API: (公開されません)
```

## パフォーマンス最適化

### 1. データベース最適化
- **インデックス**: 頻繁にクエリされるフィールドの最適化インデックス
- **複合インデックス**: 効率的なマルチフィールドクエリ
- **コネクションプーリング**: 非同期コネクション管理
- **クエリ最適化**: 効率的なルックアップパターン

### 2. 認証最適化
- **パスワードハッシュ化**: セキュリティとパフォーマンスのバランス
- **トークンキャッシング**: ステートレスJWTがデータベースルックアップを削減
- **非同期操作**: サービス全体でのノンブロッキングI/O
- **最小ペイロード**: コンパクトなトークンとレスポンスサイズ

### 3. メモリ管理
- **遅延読み込み**: 必要時のみユーザーデータを読み込み
- **コネクション再利用**: 効率的なデータベースコネクションプーリング
- **ガベージコレクション**: 適切なリソースクリーンアップ

## エラー処理

### 1. 検証エラー
- **Pydantic検証**: 自動リクエスト検証
- **カスタムバリデーター**: ドメイン固有の検証ルール
- **エラーメッセージ**: 明確で実行可能なエラー説明
- **フィールドレベルエラー**: 特定のフィールド検証フィードバック

### 2. 認証エラー
- **無効な資格情報**: セキュアなエラーメッセージ（ユーザー列挙なし）
- **トークンエラー**: 詳細なJWT検証エラー処理
- **権限エラー**: 明確な認可失敗メッセージ
- **アカウントステータス**: 非アクティブアカウントのエラー処理

### 3. システムエラー
- **データベースエラー**: 優雅なデータベース接続失敗処理
- **サービスエラー**: 適切なHTTPステータスコードマッピング
- **ログ記録**: デバッグのための包括的なエラーログ
- **リカバリー**: 自動再試行とフォールバックメカニズム

## テスト戦略

### 1. ユニットテスト
- **モデル検証**: すべてのスキーマ検証ルールをテスト
- **パスワードハッシュ化**: セキュアなパスワード処理を検証
- **JWT操作**: トークン生成と検証をテスト
- **ビジネスロジック**: ユーザー登録と認証フローをテスト

### 2. 統合テスト
- **データベース操作**: すべてのCRUD操作をテスト
- **認証フロー**: エンドツーエンド認証テスト
- **マルチテナント**: テナント分離とセキュリティをテスト
- **APIエンドポイント**: 包括的なAPIテスト

### 3. セキュリティテスト
- **パスワードセキュリティ**: ハッシュ化と検証をテスト
- **トークンセキュリティ**: JWTトークン処理をテスト
- **アクセス制御**: 認可と権限をテスト
- **入力検証**: 悪意のある入力に対してテスト

このモデル仕様は、アカウントサービスのデータ構造、セキュリティ実装の包括的な理解を提供し、認証システムの効果的な開発とメンテナンスを可能にします。